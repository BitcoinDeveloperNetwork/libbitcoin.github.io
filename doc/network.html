

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>6. Network Protocol &mdash; libbitcoin 1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="top" title="libbitcoin 1 documentation" href="index.html" />
    <link rel="next" title="7. Full Node Implementation" href="fullnode.html" />
    <link rel="prev" title="5. Fun With The Bitcoin Blockchain" href="blockchain.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="fullnode.html" title="7. Full Node Implementation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="blockchain.html" title="5. Fun With The Bitcoin Blockchain"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">libbitcoin 1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="network-protocol">
<span id="tut-network"></span><h1>6. Network Protocol<a class="headerlink" href="#network-protocol" title="Permalink to this headline">¶</a></h1>
<p>The Bitcoin protocol was defined by the software released by Satoshi.
But as Satoshi left the project and the ecosystem began to diversify,
the BIP process was created to document and reach consensus on protocol
changes.</p>
<p><a class="reference external" href="https://en.bitcoin.it/wiki/BIP_0014">BIP 14</a> adds a user agent field
to version handshake messages in the Bitcoin protocol. The format of the
user agent field is:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="o">/</span><span class="n">Name</span><span class="o">:</span><span class="n">Version</span><span class="o">/</span><span class="n">Name</span><span class="o">:</span><span class="n">Version</span><span class="o">/</span><span class="p">...</span><span class="o">/</span>
</pre></div>
</div>
<p>Reading the user agent fields from Bitcoin nodes is a useful way to gather
information about clients such as their version or the codebase they are using.
By reading user agents from the network we can gather statistics about the
general health of the Bitcoin network.</p>
<div class="section" id="simple-network-application">
<h2>6.1. Simple Network Application<a class="headerlink" href="#simple-network-application" title="Permalink to this headline">¶</a></h2>
<p>Inside <a class="reference internal" href="examples/accept.html#examples-accept"><em>examples/accept.cpp</em></a> is a simple program that
waits for a connection and displays that node&#8217;s user agent field.</p>
<div class="highlight-cpp"><pre>$ cd examples/
$ make
$ ./accept</pre>
</div>
<p>The daemon will be running on localhost and accepting connections from port
8333 (the standard Bitcoin network port).</p>
<p>The <tt class="xref cpp cpp-class docutils literal"><span class="pre">network</span></tt> service offers an interface for connecting to remote
nodes. Calling <tt class="xref cpp cpp-func docutils literal"><span class="pre">network::connect()</span></tt> will attempt to establish a connection
calling the handler once the operation is complete.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">threadpool</span> <span class="nf">pool</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">network</span> <span class="nf">net</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
<span class="n">net</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="s">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">8333</span><span class="p">,</span> <span class="n">connect_started</span><span class="p">);</span>
</pre></div>
</div>
<p>The completion handler is called once the connection is established.
The <tt class="xref cpp cpp-class docutils literal"><span class="pre">channel_ptr</span></tt> is our connection to the node, at which point
we can begin sending.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">connect_started</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span> <span class="n">channel_ptr</span> <span class="n">node</span><span class="p">);</span>
</pre></div>
</div>
<p>During the first stage of a connection between 2 nodes, they will swap
version messages and version acknowledgement messages. This is the
initialization handshake in the Bitcoin protocol. Before anything happens,
the handshake protocol should be completed.</p>
<p>We define a version message with several fields filled in. The interesting line
is where we set the user agent. Anything is possible in this field, but
<a class="reference external" href="https://en.bitcoin.it/wiki/BIP_0014">BIP 14</a> specifies a specific format
for this field.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// Create our version message we want to send.</span>
<span class="c1">// Fill in a bunch of fields.</span>
<span class="n">version_type</span> <span class="n">version</span><span class="p">;</span>
<span class="n">version</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="mi">60000</span><span class="p">;</span>
<span class="n">version</span><span class="p">.</span><span class="n">services</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">version</span><span class="p">.</span><span class="n">address_me</span><span class="p">.</span><span class="n">services</span> <span class="o">=</span> <span class="n">version</span><span class="p">.</span><span class="n">services</span><span class="p">;</span>
<span class="n">version</span><span class="p">.</span><span class="n">address_me</span><span class="p">.</span><span class="n">ip</span> <span class="o">=</span>
    <span class="n">ip_address_type</span><span class="p">{</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
                    <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x0a</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">};</span>
<span class="n">version</span><span class="p">.</span><span class="n">address_me</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="mi">8333</span><span class="p">;</span>
<span class="n">version</span><span class="p">.</span><span class="n">address_you</span><span class="p">.</span><span class="n">services</span> <span class="o">=</span> <span class="n">version</span><span class="p">.</span><span class="n">services</span><span class="p">;</span>
<span class="n">version</span><span class="p">.</span><span class="n">address_you</span><span class="p">.</span><span class="n">ip</span> <span class="o">=</span>
    <span class="n">ip_address_type</span><span class="p">{</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
                    <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x0a</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">};</span>
<span class="n">version</span><span class="p">.</span><span class="n">address_you</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="mi">8333</span><span class="p">;</span>
<span class="c1">// Set the user agent.</span>
<span class="n">version</span><span class="p">.</span><span class="n">user_agent</span> <span class="o">=</span> <span class="s">&quot;/libbitcoin/connect-test/&quot;</span><span class="p">;</span>
<span class="n">version</span><span class="p">.</span><span class="n">start_height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">version</span><span class="p">.</span><span class="n">nonce</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span>
</pre></div>
</div>
<p>We then send the message by calling <tt class="xref cpp cpp-func docutils literal"><span class="pre">channel::send()</span></tt> on the
<tt class="xref cpp cpp-class docutils literal"><span class="pre">channel_ptr</span></tt> object.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// Begin the send.</span>
<span class="c1">// Calls version_sent callback when complete.</span>
<span class="n">node</span><span class="o">-&gt;</span><span class="n">send</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">version_sent</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">node</span><span class="p">));</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="examples/connect.html#examples-connect"><em>examples/connect.cpp</em></a> for the full source code.</p>
<div class="section" id="accept-connections">
<h3>6.1.1. Accept Connections<a class="headerlink" href="#accept-connections" title="Permalink to this headline">¶</a></h3>
<p>To accept connections, we begin a listen operation which returns an
<tt class="xref cpp cpp-class docutils literal"><span class="pre">acceptor_ptr</span></tt>. Then we call <tt class="xref cpp cpp-func docutils literal"><span class="pre">acceptor::accept()</span></tt> which calls
our provided callback when a new connection is made to our node.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">net</span><span class="p">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">8333</span><span class="p">,</span> <span class="n">listening_started</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">listening_started</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span> <span class="n">acceptor_ptr</span> <span class="n">accept</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="c1">// Accept first connection.</span>
    <span class="n">accept</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="n">accepted_connection</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">accepted_connection</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span> <span class="n">channel_ptr</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This initiates the accept, but once a connection is established, the
<tt class="xref cpp cpp-class docutils literal"><span class="pre">acceptor</span></tt> stops. We therefore need to call <tt class="xref cpp cpp-func docutils literal"><span class="pre">acceptor::accept()</span></tt>
to keep listening for new connections.</p>
<p>We pass the <tt class="xref cpp cpp-class docutils literal"><span class="pre">acceptor_ptr</span></tt> by binding it as an argument to the callback
for when a new connection is accepted.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">listening_started</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span> <span class="n">acceptor_ptr</span> <span class="n">accept</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="c1">// Accept first connection.</span>
    <span class="n">accept</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">accepted_connection</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">accept</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">accepted_connection</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span> <span class="n">channel_ptr</span> <span class="n">node</span><span class="p">,</span>
    <span class="n">acceptor_ptr</span> <span class="n">accept</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">log_info</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Accepted connection!&quot;</span><span class="p">;</span>
    <span class="c1">// Keep accepting more connections.</span>
    <span class="n">accept</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">accepted_connection</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">accept</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We want to be notified of version messages from the host and display the
user agent.</p>
<dl class="function">
<dt id="channel::subscribe_version__receive_version_handler">
void <tt class="descclassname">channel::</tt><tt class="descname">subscribe_version</tt><big>(</big>receive_version_handler <em>handle_receive</em><big>)</big><a class="headerlink" href="#channel::subscribe_version__receive_version_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Subscribe to version messages from the node. Unsubscribes when the message
is received. To stay subscribed, call this method again inside the
receiving handler.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">handle_receive</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span>  <span class="c1">// Status of operation</span>
    <span class="k">const</span> <span class="n">version_type</span><span class="o">&amp;</span> <span class="n">tx</span>      <span class="c1">// Version message</span>
<span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<p>We use this method to receive a single version message, and print the
user agent field.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">accepted_connection</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span> <span class="n">channel_ptr</span> <span class="n">node</span><span class="p">,</span>
    <span class="n">acceptor_ptr</span> <span class="n">accept</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">log_error</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Accept: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">message</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">log_info</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Accepted connection!&quot;</span><span class="p">;</span>
    <span class="c1">// Now we need to keep it alive otherwise the connection is closed.</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">subscribe_version</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">version_received</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">node</span><span class="p">));</span>
    <span class="c1">// Keep accepting more connections.</span>
    <span class="n">accept</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">accepted_connection</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">accept</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">version_received</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span> <span class="k">const</span> <span class="n">version_type</span><span class="o">&amp;</span> <span class="n">version</span><span class="p">,</span>
    <span class="n">channel_ptr</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// error::service_stopped means the connection was closed.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ec</span> <span class="o">==</span> <span class="n">error</span><span class="o">::</span><span class="n">service_stopped</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">log_error</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Version message: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">message</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">log_info</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;User agent: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">version</span><span class="p">.</span><span class="n">user_agent</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="examples/connect.html#examples-connect"><em>examples/connect.cpp</em></a> for the full source code.</p>
</div>
<div class="section" id="handshake-service">
<h3>6.1.2. handshake Service<a class="headerlink" href="#handshake-service" title="Permalink to this headline">¶</a></h3>
<p>Before a node will respond to your traffic, you must complete the version
handshake which is swapping a verack (version acknowledgement) with their
version, and giving a version and getting a verack in response.</p>
<p>We can do this ourselves, but then there are other tasks like fetching our
IP address (which is done from a few websites). We can only speculate why
Satoshi decided to require such a strange task. libbitcoin stays faithful
to the Bitcoin protocol by Satoshi and conforms to this requirement.</p>
<p>For this libbitcoin provides a <tt class="xref cpp cpp-class docutils literal"><span class="pre">handshake</span></tt> service which performs
the composed operation of doing the initial handshake.</p>
<p>If you&#8217;re not interested in the process of creating your own network
connection channel and then calling the <tt class="xref cpp cpp-class docutils literal"><span class="pre">handshake</span></tt> service, then
use the <a class="reference internal" href="blockchain.html#composed-operations"><em>composed operation</em></a> <tt class="xref cpp cpp-func docutils literal"><span class="pre">connect()</span></tt>.</p>
</div>
</div>
<div class="section" id="network-services">
<h2>6.2. Network Services<a class="headerlink" href="#network-services" title="Permalink to this headline">¶</a></h2>
<p>Here is a list of the network-related services present in <tt class="docutils literal"><span class="pre">&lt;bitcoin/network/*.hpp&gt;</span></tt>.</p>
<ul class="simple">
<li><tt class="xref cpp cpp-class docutils literal"><span class="pre">channel</span></tt>: a basic communication channel to a node. Allows you to
send and receive messages from Bitcoin nodes (see
<tt class="docutils literal"><span class="pre">&lt;bitcoin/primitives.hpp&gt;</span></tt>).</li>
<li><tt class="xref cpp cpp-class docutils literal"><span class="pre">acceptor</span></tt>: allows you to accept inbound connections from other nodes.</li>
<li><tt class="xref cpp cpp-class docutils literal"><span class="pre">network</span></tt>: creates connections and spawns <tt class="xref cpp cpp-class docutils literal"><span class="pre">acceptor</span></tt> instances.</li>
<li><tt class="xref cpp cpp-class docutils literal"><span class="pre">handshake</span></tt>: handles the initialization handshake.</li>
<li><tt class="xref cpp cpp-class docutils literal"><span class="pre">hosts</span></tt>: stores a list of all nodes and allows random fetches from that list.</li>
<li><tt class="xref cpp cpp-class docutils literal"><span class="pre">protocol</span></tt>: handles the node discovery mechanism, negotiation
through the protocol and managing a consistent number of connections.</li>
</ul>
<p><tt class="xref cpp cpp-class docutils literal"><span class="pre">protocol</span></tt> is the class most developers will use to create a bunch of
connections to the network and manage them.</p>
<dl class="function">
<dt id="protocol::subscribe_channel__channel_handler">
void <tt class="descclassname">protocol::</tt><tt class="descname">subscribe_channel</tt><big>(</big>channel_handler <em>handle_channel</em><big>)</big><a class="headerlink" href="#protocol::subscribe_channel__channel_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Subscribe to new connections established to other nodes.
This method must be called again to stay subscribed as
handlers are deregistered after being called.</p>
<p>When this protocol service is stopped, any subscribed handlers
will be called with the <tt class="xref cpp cpp-class docutils literal"><span class="pre">std::error_code</span></tt> set to
<tt class="xref cpp cpp-class docutils literal"><span class="pre">error::service_stopped</span></tt>.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">handle_channel</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span>  <span class="c1">// Status of operation</span>
    <span class="n">channel_ptr</span> <span class="n">node</span>            <span class="c1">// Communication channel to new node</span>
<span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="protocol::fetch_connection_count__fetch_connection_count_handler">
void <tt class="descclassname">protocol::</tt><tt class="descname">fetch_connection_count</tt><big>(</big>fetch_connection_count_handler <em>handle_fetch</em><big>)</big><a class="headerlink" href="#protocol::fetch_connection_count__fetch_connection_count_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch the number of connections we have to the network.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">handle_fetch</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span>  <span class="c1">// Status of operation</span>
    <span class="kt">size_t</span> <span class="n">connection_count</span>
<span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="protocol::broadcast:Message:__MessageCR">
void <tt class="descclassname">protocol::</tt><tt class="descname">broadcast&lt;Message&gt;</tt><big>(</big>const Message&amp; <em>packet</em><big>)</big><a class="headerlink" href="#protocol::broadcast:Message:__MessageCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcast packet to all our connected nodes.</p>
</dd></dl>

</div>
<div class="section" id="join-the-peer-to-peer-network">
<span id="tut-protocol"></span><h2>6.3. Join the Peer To Peer Network<a class="headerlink" href="#join-the-peer-to-peer-network" title="Permalink to this headline">¶</a></h2>
<p>We start with a simple program which connects to random Bitcoin nodes in
the network. It displays the connection count every second.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;bitcoin/bitcoin.hpp&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">bc</span><span class="p">;</span>

<span class="c1">// We don&#39;t have a database open, and aren&#39;t doing any critical file</span>
<span class="c1">// operations so we aren&#39;t worried about exiting suddenly.</span>
<span class="kt">void</span> <span class="nf">check_error</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ec</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="n">log_fatal</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">message</span><span class="p">();</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">handle_start</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">check_error</span><span class="p">(</span><span class="n">ec</span><span class="p">);</span>
    <span class="n">log_debug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Started.&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">display_number_of_connections</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">connection_count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">check_error</span><span class="p">(</span><span class="n">ec</span><span class="p">);</span>
    <span class="n">log_debug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">connection_count</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; CONNECTIONS&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Needed for the C callback capturing the signals.</span>
<span class="kt">bool</span> <span class="n">stopped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">signal_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">log_info</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Caught signal: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">sig</span><span class="p">;</span>
    <span class="n">stopped</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">threadpool</span> <span class="n">pool</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// Create dependencies for our protocol object.</span>
    <span class="n">hosts</span> <span class="n">hst</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
    <span class="n">handshake</span> <span class="n">hs</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
    <span class="n">network</span> <span class="n">net</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
    <span class="c1">// protocol service.</span>
    <span class="n">protocol</span> <span class="n">prot</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">hst</span><span class="p">,</span> <span class="n">hs</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
    <span class="c1">// Perform node discovery if needed and then creating connections.</span>
    <span class="n">prot</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">handle_start</span><span class="p">);</span>
    <span class="c1">// Catch C signals for stopping the program.</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGABRT</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">);</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">);</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stopped</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">prot</span><span class="p">.</span><span class="n">fetch_connection_count</span><span class="p">(</span><span class="n">display_number_of_connections</span><span class="p">);</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Safely close down.</span>
    <span class="n">pool</span><span class="p">.</span><span class="n">stop</span><span class="p">();</span>
    <span class="n">pool</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For notifications about new connections, <a class="reference internal" href="#protocol::subscribe_channel__channel_handler" title="protocol::subscribe_channel"><tt class="xref cpp cpp-func docutils literal"><span class="pre">protocol::subscribe_channel()</span></tt></a>
calls a given notification handler when a new channel becomes available.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// ...</span>
<span class="n">prot</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">handle_start</span><span class="p">);</span>
<span class="c1">// Notify us of new connections.</span>
<span class="c1">// We can subscribe to protocol at any time after start() is called.</span>
<span class="n">prot</span><span class="p">.</span><span class="n">subscribe_channel</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">connection_started</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">prot</span><span class="p">)));</span>
</pre></div>
</div>
<p>We pass the <tt class="xref cpp cpp-class docutils literal"><span class="pre">protocol</span></tt> service in by reference and resubscribe.
<tt class="xref cpp cpp-func docutils literal"><span class="pre">connection_started()</span></tt> is <em>continuously</em> notified of new
communication channels when they are opened.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">connection_started</span><span class="p">(</span><span class="n">channel_ptr</span> <span class="n">node</span><span class="p">,</span> <span class="n">protocol</span><span class="o">&amp;</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">log_warning</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Couldn&#39;t start connection: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">message</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">log_info</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Connection established.&quot;</span><span class="p">;</span>
    <span class="c1">// Resubscribe to new nodes.</span>
    <span class="n">prot</span><span class="p">.</span><span class="n">subscribe_channel</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">connection_started</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">prot</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="examples/proto.html#examples-proto"><em>examples/proto.cpp</em></a> for the full source code.</p>
<div class="section" id="transaction-radar">
<h3>6.3.1. Transaction Radar<a class="headerlink" href="#transaction-radar" title="Permalink to this headline">¶</a></h3>
<p>Transactions can be traced throughout the network by maintaining nodes
with high connectivity. This is how a <em>transaction radar</em> works.
It monitors 100 nodes and gives a % propagation for a transaction
depending on how many of those nodes report back a particular transaction.
When 100 nodes have reported the transaction, the radar says it is propagated 100%.
This can also be used to triangulate the origin of new transactions.</p>
<p>We will implement a simple version which keeps track of transaction hashes
and their relay count (the number of notifications for this transaction).
Old items will be cleaned out once their timestamp expires. We have a method
to display.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// Watches transactions. Keeps a view count per seen tx hash, and</span>
<span class="c1">// cleans up old expired tx hashes.</span>
<span class="k">class</span> <span class="nc">tx_watch</span>
  <span class="o">:</span> <span class="k">public</span> <span class="n">async_strand</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">tx_watch</span><span class="p">(</span><span class="n">threadpool</span><span class="o">&amp;</span> <span class="n">pool</span><span class="p">,</span> <span class="kt">time_t</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">200</span><span class="p">);</span>

    <span class="c1">// Push a seen tx hash. If this entry exists then the count</span>
    <span class="c1">// will be incremented.</span>
    <span class="c1">// Else create a new entry in our list.</span>
    <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="k">const</span> <span class="n">hash_digest</span><span class="o">&amp;</span> <span class="n">tx_hash</span><span class="p">);</span>
    <span class="c1">// Cleans up expired items. We could make this implicitly called</span>
    <span class="c1">// by push() or display(), but single use methods with no side-effects</span>
    <span class="c1">// is better code design.</span>
    <span class="kt">void</span> <span class="nf">cleanup</span><span class="p">();</span>
    <span class="c1">// Display transactions and their count. A better design would be to</span>
    <span class="c1">// separate the view from the model and instead provide a method which</span>
    <span class="c1">// fetches a copy of our list, but we keep it simple here.</span>
    <span class="kt">void</span> <span class="nf">display</span><span class="p">();</span>

<span class="nl">private:</span>
    <span class="k">struct</span> <span class="n">entry_count</span>
    <span class="p">{</span>
        <span class="n">hash_digest</span> <span class="n">tx_hash</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>
        <span class="c1">// Timestamp of when transaction hash was first seen.</span>
        <span class="kt">time_t</span> <span class="n">timest</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">entry_count</span><span class="o">&gt;</span> <span class="n">entry_list</span><span class="p">;</span>

    <span class="c1">// The public methods push these methods to the threadpool to be</span>
    <span class="c1">// executed and then return immediately.</span>
    <span class="c1">// async_strand::queue() is a helper method which posts the work</span>
    <span class="c1">// to the threadpool and serializes access.</span>
    <span class="c1">// No 2 operations posted through the same async_strand using queue()</span>
    <span class="c1">// will execute at the same time.</span>
    <span class="kt">void</span> <span class="nf">do_push</span><span class="p">(</span><span class="k">const</span> <span class="n">hash_digest</span><span class="o">&amp;</span> <span class="n">tx_hash</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">do_cleanup</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">do_display</span><span class="p">();</span>

    <span class="n">entry_list</span> <span class="n">entries_</span><span class="p">;</span>
    <span class="c1">// Time until an entry is ready to be removed.</span>
    <span class="kt">time_t</span> <span class="n">timeout_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The implementation for this class is standard C++. We try to find the
relevant entry when <tt class="xref cpp cpp-func docutils literal"><span class="pre">push()</span></tt> is called, otherwise we create a new one.
<tt class="xref cpp cpp-func docutils literal"><span class="pre">cleanup()</span></tt> looks for expired items and erases them. <tt class="xref cpp cpp-func docutils literal"><span class="pre">display()</span></tt>
orders the entry table and displays the top 20 items.</p>
<p>Note the usage of <tt class="xref cpp cpp-class docutils literal"><span class="pre">async_strand</span></tt> which depends on <tt class="xref cpp cpp-class docutils literal"><span class="pre">threadpool</span></tt>.
It provides a <tt class="xref cpp cpp-func docutils literal"><span class="pre">async_strand::queue()</span></tt> method which executes callbacks
asynchronously. Callbacks called in the same <tt class="xref cpp cpp-class docutils literal"><span class="pre">async_strand</span></tt> will
<strong>not</strong> execute in parallel. In this way race conditions are avoided around
shared class members without the use of locks. If an <tt class="xref cpp cpp-class docutils literal"><span class="pre">async_strand</span></tt>
is busy then the <tt class="xref cpp cpp-class docutils literal"><span class="pre">threadpool</span></tt> will simply execute another operation
that doesn&#8217;t conflict.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">tx_watch</span><span class="o">::</span><span class="n">tx_watch</span><span class="p">(</span><span class="n">threadpool</span><span class="o">&amp;</span> <span class="n">pool</span><span class="p">,</span> <span class="kt">time_t</span> <span class="n">timeout</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">async_strand</span><span class="p">(</span><span class="n">pool</span><span class="p">),</span> <span class="n">timeout_</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">tx_watch</span><span class="o">::</span><span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">hash_digest</span><span class="o">&amp;</span> <span class="n">tx_hash</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">queue</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_watch</span><span class="o">::</span><span class="n">do_push</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">tx_hash</span><span class="p">));</span>
    <span class="c1">// Returns immediately.</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">tx_watch</span><span class="o">::</span><span class="n">do_push</span><span class="p">(</span><span class="k">const</span> <span class="n">hash_digest</span><span class="o">&amp;</span> <span class="n">tx_hash</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// If tx_hash is found then increment count...</span>
    <span class="kt">bool</span> <span class="n">is_found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">entry_count</span><span class="o">&amp;</span> <span class="n">entry</span><span class="o">:</span> <span class="n">entries_</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">tx_hash</span> <span class="o">==</span> <span class="n">tx_hash</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">++</span><span class="n">entry</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
            <span class="n">is_found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="c1">// Else create a new entry with a count of 1.</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_found</span><span class="p">)</span>
        <span class="n">entries_</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">tx_hash</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)});</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">tx_watch</span><span class="o">::</span><span class="n">cleanup</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">queue</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_watch</span><span class="o">::</span><span class="n">do_cleanup</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">tx_watch</span><span class="o">::</span><span class="n">do_cleanup</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Erase entries where timest is older than (now - timeout_) seconds.</span>
    <span class="kt">time_t</span> <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="n">nullptr</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">erase_pred</span> <span class="o">=</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">entry_count</span><span class="o">&amp;</span> <span class="n">entry</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">current_time</span> <span class="o">-</span> <span class="n">entry</span><span class="p">.</span><span class="n">timest</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">timeout_</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="k">auto</span> <span class="n">erase_begin</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">remove_if</span><span class="p">(</span><span class="n">entries_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">entries_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">erase_pred</span><span class="p">);</span>
    <span class="c1">// If we have old entries to delete then erase them.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">erase_begin</span> <span class="o">!=</span> <span class="n">entries_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
        <span class="n">entries_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">erase_begin</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">tx_watch</span><span class="o">::</span><span class="n">display</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">queue</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_watch</span><span class="o">::</span><span class="n">do_display</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">tx_watch</span><span class="o">::</span><span class="n">do_display</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Sort entries by count. Highest numbers at the top.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">entries_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">entries_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
        <span class="p">[](</span><span class="k">const</span> <span class="n">entry_count</span><span class="o">&amp;</span> <span class="n">entry_a</span><span class="p">,</span> <span class="k">const</span> <span class="n">entry_count</span><span class="o">&amp;</span> <span class="n">entry_b</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">entry_a</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">entry_b</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="c1">// Display the first 20 entries.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">entries_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">entry_count</span><span class="o">&amp;</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">entries_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">log_info</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">entry</span><span class="p">.</span><span class="n">tx_hash</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">entry</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We now tie this in with our code above. When a new connection is started,
we subscribe to inventory packets originating from that node. For every
inventory packet sent by that node, we read off the transaction hashes and
add it to our <tt class="xref cpp cpp-class docutils literal"><span class="pre">tx_watch</span></tt> object.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">connection_started</span><span class="p">(</span><span class="n">channel_ptr</span> <span class="n">node</span><span class="p">,</span> <span class="n">protocol</span><span class="o">&amp;</span> <span class="n">prot</span><span class="p">,</span> <span class="n">tx_watch</span><span class="o">&amp;</span> <span class="n">watch</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">inventory_received</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span> <span class="k">const</span> <span class="n">inventory_type</span><span class="o">&amp;</span> <span class="n">inv</span><span class="p">,</span>
    <span class="n">channel_ptr</span> <span class="n">node</span><span class="p">,</span> <span class="n">tx_watch</span><span class="o">&amp;</span> <span class="n">watch</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">connection_started</span><span class="p">(</span><span class="n">channel_ptr</span> <span class="n">node</span><span class="p">,</span> <span class="n">protocol</span><span class="o">&amp;</span> <span class="n">prot</span><span class="p">,</span> <span class="n">tx_watch</span><span class="o">&amp;</span> <span class="n">watch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">log_warning</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Couldn&#39;t start connection: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">message</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">log_info</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Connection established.&quot;</span><span class="p">;</span>
    <span class="c1">// Subscribe to inventory packets.</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">subscribe_inventory</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">inventory_received</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">watch</span><span class="p">)));</span>
    <span class="c1">// Resubscribe to new nodes.</span>
    <span class="n">prot</span><span class="p">.</span><span class="n">subscribe_channel</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">connection_started</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">prot</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">watch</span><span class="p">)));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">inventory_received</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span> <span class="k">const</span> <span class="n">inventory_type</span><span class="o">&amp;</span> <span class="n">inv</span><span class="p">,</span>
    <span class="n">channel_ptr</span> <span class="n">node</span><span class="p">,</span> <span class="n">tx_watch</span><span class="o">&amp;</span> <span class="n">watch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">check_error</span><span class="p">(</span><span class="n">ec</span><span class="p">);</span>
    <span class="c1">// Loop through inventory hashes.</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">inventory_vector_type</span><span class="o">&amp;</span> <span class="n">ivec</span><span class="o">:</span> <span class="n">inv</span><span class="p">.</span><span class="n">inventories</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// We&#39;re only interested in transactions. Discard everything else.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ivec</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">inventory_type_id</span><span class="o">::</span><span class="n">transaction</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="n">watch</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">ivec</span><span class="p">.</span><span class="n">hash</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Resubscribe to inventory packets.</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">subscribe_inventory</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">inventory_received</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">watch</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the main runloop, we display the transaction radar table periodically.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// Our table tracking transaction counts.</span>
<span class="n">tx_watch</span> <span class="nf">watch</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>
<span class="c1">// Notify us of new connections.</span>
<span class="n">prot</span><span class="p">.</span><span class="n">subscribe_channel</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">connection_started</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">prot</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">watch</span><span class="p">)));</span>
<span class="c1">// ...</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stopped</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">watch</span><span class="p">.</span><span class="n">cleanup</span><span class="p">();</span>
    <span class="n">watch</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="examples/txrad.html#examples-txrad"><em>examples/txrad.cpp</em></a> for the full source code.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">6. Network Protocol</a><ul>
<li><a class="reference internal" href="#simple-network-application">6.1. Simple Network Application</a><ul>
<li><a class="reference internal" href="#accept-connections">6.1.1. Accept Connections</a></li>
<li><a class="reference internal" href="#handshake-service">6.1.2. handshake Service</a></li>
</ul>
</li>
<li><a class="reference internal" href="#network-services">6.2. Network Services</a></li>
<li><a class="reference internal" href="#join-the-peer-to-peer-network">6.3. Join the Peer To Peer Network</a><ul>
<li><a class="reference internal" href="#transaction-radar">6.3.1. Transaction Radar</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="blockchain.html"
                        title="previous chapter">5. Fun With The Bitcoin Blockchain</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="fullnode.html"
                        title="next chapter">7. Full Node Implementation</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/network.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="fullnode.html" title="7. Full Node Implementation"
             >next</a> |</li>
        <li class="right" >
          <a href="blockchain.html" title="5. Fun With The Bitcoin Blockchain"
             >previous</a> |</li>
        <li><a href="index.html">libbitcoin 1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, libbitcoin.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>